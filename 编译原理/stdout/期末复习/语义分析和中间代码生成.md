# 语义分析和中间代码生成



## #define

```

```



## 语义分析

### 范围

```
语义分析的范围
    1.确定类型：确定标识符所关联的数据类型。
    2.类型检查：按语言的类型规则，检查运算的合法性与运算分量类型的一致性，必要时作类型转换。
    3.识别含义：根据语言的语义定义（形式或非形式），识别程序中各构造成分组合到一起的含义，并作相应的语义处理（生成中间代码或目标代码）。
    4.控制流检查：控制流语句必须转移到合法的地方。如C中，break语句规定跳出最内层的循环或switch语句。
    5.一致性检查：在很多场合要求对象只能被说明一次。如：pascal语言规定同一个标识符在一个分程序中只能被说明一次等。
    6.相关名字检查：如：Ada，循环或块可以有一个名字，它出现在这些结构的开头或结尾。编译程序必须检查这两个地方用的名字是否相同。
```



### 好处

```
    (1) 于进行与机器无关的代码优化工作；
    (2) 便编译程序改变目标机更容易；
    (3) 便编译程序的结构在逻辑上更为简单明确。以中间语言为界面，编译前端和后端的接口更清晰。
```



## 中间语言



### 后缀式（逆波兰表达式）

```
就是对于中缀表达式的后续遍历
例如：
	a*(b+c) 的后缀式为 abc*
```



### 三地址代码

```
一般形式：
	x := y op z

其中：
	x y z 为名字
	op 表示操作符

```

三地址代码有三种表现形式

-   [四元式](#四元式)
-   [三元式](#三元式)
-   [间接三元式](#间接三元式)



#### 四元式

```
四元式是一个带有四个域的记录结构：
	result := arg1 op arg2
	
```

例如 `a:=b*c+b*c` 的四元式为

|         | **Op**     | **Arg1** | **Arg2** | **Result** |
| ------- | ---------- | -------- | -------- | ---------- |
| **(0)** | **uminus** | **c**    |          | **T1**     |
| **(1)** | *****      | **b**    | **T1**   | **T2**     |
| **(2)** | **uminus** | **c**    |          | **T3**     |
| **(3)** | *****      | **b**    | **T3**   | **T4**     |
| **(4)** | **+**      | **T3**   | **T4**   | **T5**     |
| **(5)** | **:=**     | **T5**   |          | **a**      |

#### 三元式

```
三元式可以理解成把 四元式产生的临时变量替换成了操作序号
```

例如 `a:=b*c+b*c` 的三元式

| ** **   | **Op**     | **Arg1** | **Arg2** |
| ------- | ---------- | -------- | -------- |
| **(0)** | **uminus** | **c**    |          |
| **(1)** | *****      | **b**    | **(0)**  |
| **(2)** | **uminus** | **c**    |          |
| **(3)** | *****      | **b**    | **(2)**  |
| **(4)** | **+**      | **(1)**  | **(3)**  |
| **(5)** | **:=**     | **a**    | **(4)**  |



#### 间接三元式

```
在三元式的基础上，增加了一个简介码表，用来表示三元式中运算顺序
在代码优化的过程中，只需要改动简介码表中的顺序，而不需要改变三元式表
```

`X=(A+B)∗C`
`Y=D↑(A+B)`



| 间接码表 | 三元式表             |
| -------- | -------------------- |
| （1）    | （1）（+，A，B）     |
| （2）    | （2）（*，（1），C） |
| （3）    | （3）（=，X，（2）） |
| （1）    | （4）（↑，D，（1）） |
| （4）    | （5）（=，Y（4））   |
| （5）    |                      |

理解

```
对于 1 2 3来说，按顺序执行
对于 4 来说，由于用到了 1 的计算式，而且不连续，所以先计算 1 ，而后是 4 
```



## 语句的翻译



### 说明语句

```
我的理解是 int a; 这样的说明 a 变量的数据类型，而不起到实际实际运算的句子

	全程变量offset来跟踪一个可用的相对地址的位置；
	过程enter (name, type, offset) 用来把名字name填入到符号表中，并给出此名字的类型为type及在过程数据区中的相对地址为offset。
	
	所以又需要一个综合属性 width 来表示非终结符 T 占用的空间大小
```



### 赋值语句

```
先检查 T.name 是否存在 
	存在：得到地址，产生三地址代码
	不存在：报错
```



### 数组

```
使用 
	base + (i - low) * w
	
说明：
	base 表示基址
	i 表示下标
	low 表示数组的下界（一般是0）
	w 表示数组类型的宽度
```



### bool

```
懒得看了，挖个坑（）
```

